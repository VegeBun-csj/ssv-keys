{
  "version": 3,
  "sources": ["../../src/lib/SSVKeys.ts", "../../src/lib/BLS/index.ts", "../../src/lib/Threshold/Threshold.ts", "../../src/lib/Encryption/Encryption.ts", "../../src/lib/JSEncrypt/index.ts", "../../src/lib/SSVNetworkContract.ts", "../../src/lib/EthereumKeyStore/EthereumKeyStore.ts"],
  "sourcesContent": ["import atob from 'atob';\nimport Web3 from 'web3';\nimport { encode } from 'js-base64';\nimport EthereumKeyStore from 'eth2-keystore-js';\nimport Threshold, { IShares, ISharesKeyPairs } from './Threshold';\nimport Encryption, { EncryptShare } from './Encryption/Encryption';\n\nexport class SSVKeys {\n  static OPERATOR_FORMAT_BASE64 = 'base64';\n\n  protected web3Instances: any = {};\n\n  getWeb3(nodeUrl = process.env.NODE_URL || ''): Web3 {\n    if (!this.web3Instances[nodeUrl]) {\n      this.web3Instances[nodeUrl] = new Web3(String(nodeUrl || ''))\n    }\n    return this.web3Instances[nodeUrl];\n  }\n\n  /**\n   * Extract private key from keystore data using keystore password.\n   * Generally can be used in browsers when the keystore data has been provided by browser.\n   * @param data\n   * @param password\n   */\n  async getPrivateKeyFromKeystoreData(data: string, password: string): Promise<string> {\n    try {\n      try {\n        // Try to json parse the data before\n        data = JSON.parse(data);\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n\n      const keyStore = new EthereumKeyStore(data);\n      return await keyStore.getPrivateKey(password).then((privateKey: string) => privateKey);\n    } catch (error: any) {\n      return error;\n    }\n  }\n\n  /**\n   * Build threshold using private key for number of participants and failed participants.\n   * TODO: make it possible to choose how many fails can be in threshold\n   * @param privateKey\n   */\n  async createThreshold(privateKey: string): Promise<ISharesKeyPairs> {\n    try {\n      const threshold: Threshold = new Threshold();\n      return threshold.create(privateKey);\n    } catch (error: any) {\n      return error;\n    }\n  }\n\n  /**\n   * Encrypt operators shares using operators public keys.\n   * @param operatorsPublicKeys\n   * @param shares\n   * @param operatorFormat\n   */\n  async encryptShares(operatorsPublicKeys: string[], shares: IShares[],\n                      operatorFormat = SSVKeys.OPERATOR_FORMAT_BASE64): Promise<EncryptShare[]> {\n    try {\n      const decodedOperators = operatorsPublicKeys.map((operator: string) => {\n        operator = atob(operator);\n        return operatorFormat == SSVKeys.OPERATOR_FORMAT_BASE64\n          ? String(encode(operator)) : operator;\n      });\n      return new Encryption(decodedOperators, shares).encrypt();\n    } catch (error: any) {\n      return error;\n    }\n  }\n\n  /**\n   * Encode with Web3 eth abi method any fields of shares array required for transaction.\n   * @param encryptedShares\n   * @param field\n   */\n  abiEncode(encryptedShares: EncryptShare[], field: string): string[] {\n    return encryptedShares.map((share: EncryptShare) => {\n      return this.getWeb3().eth.abi.encodeParameter('string', Object(share)[field]);\n    });\n  }\n\n  /**\n   * Having keystore private key build final transaction payload for list of operators.\n   *\n   * Example:\n   *\n   *    const privateKey = await ssvKeys.getPrivateKeyFromKeystoreFile(keystoreFilePath, keystorePassword);\n   *    const encryptedShares = await ssvKeys.encryptShares(operatorsPublicKeys, shares);\n   *    await ssvKeys.buildPayload(privateKey, encryptedShares)\n   *\n   * @param privateKey\n   * @param encryptedShares\n   */\n  async buildPayload(privateKey: string, encryptedShares: EncryptShare[]): Promise<any[]> {\n    const threshold: ISharesKeyPairs = await this.createThreshold(privateKey);\n    const operatorsPublicKey: string[] = this.abiEncode(encryptedShares, 'operatorPublicKey');\n    const sharePublicKey: string[] = encryptedShares.map((share: EncryptShare) => share.publicKey);\n    const sharePrivateKey: string[] = this.abiEncode(encryptedShares, 'privateKey');\n    return [\n      threshold.validatorPublicKey,\n      operatorsPublicKey,\n      sharePublicKey,\n      sharePrivateKey,\n    ];\n  }\n}\n", "let index: any;\n\ntry {\n  window.crypto;\n  index = require('bls-eth-wasm/browser');\n} catch {\n  index = require('bls-eth-wasm');\n}\n\nexport default index;\n", "import { SecretKeyType } from 'bls-eth-wasm';\nimport bls from '../BLS';\n\nexport interface IShares {\n    privateKey: string,\n    publicKey: string,\n    id?: any\n}\n\nexport interface ISharesKeyPairs {\n    validatorPrivateKey: string,\n    validatorPublicKey: string,\n    shares: IShares[]\n}\n\n/**\n * Building threshold for\n * Example of usage:\n *\n *  const threshold: Threshold = new Threshold();\n *  threshold.create('45df68ab75bb7ed1063b7615298e81c1ca1b0c362ef2e93937b7bba9d7c43a94').then((s) => {\n *    console.log(s);\n *  });\n */\nclass Threshold {\n    protected validatorPublicKey: any;\n    protected validatorPrivateKey: any;\n    protected validatorShares: Array<any> = [];\n\n    static get DEFAULT_SHARES_NUMBER(): number {\n      return 4;\n    }\n\n    static get DEFAULT_THRESHOLD_NUMBER(): number {\n      return 3;\n    }\n\n    /**\n     * Generate keys and return promise\n     */\n    async create(privateKey: string, sharesNumber=Threshold.DEFAULT_SHARES_NUMBER, thresholdNumber=Threshold.DEFAULT_THRESHOLD_NUMBER): Promise<ISharesKeyPairs> {\n        return new Promise((resolve, reject) => {\n            try {\n                bls.init(bls.BLS12_381)\n                    .then(() => {\n                        const msk = [];\n                        const mpk = [];\n\n                        // Master key Polynomial\n                        this.validatorPrivateKey = bls.deserializeHexStrToSecretKey(privateKey);\n                        this.validatorPublicKey = this.validatorPrivateKey.getPublicKey();\n\n                        msk.push(this.validatorPrivateKey);\n                        mpk.push(this.validatorPublicKey);\n\n                        // Construct poly\n                        for (let i = 1; i < thresholdNumber; i += 1) {\n                            const sk: SecretKeyType = new bls.SecretKey();\n                            sk.setByCSPRNG();\n                            msk.push(sk);\n                            const pk = sk.getPublicKey();\n                            mpk.push(pk);\n                        }\n\n                        // Evaluate shares - starting from 1 because 0 is master key\n                        for (let i = 1; i <= sharesNumber; i += 1) {\n                            const id = new bls.Id();\n                            id.setInt(i);\n                            const shareSecretKey = new bls.SecretKey();\n                            shareSecretKey.share(msk, id);\n\n                            const sharePublicKey = new bls.PublicKey();\n                            sharePublicKey.share(mpk, id);\n\n                            this.validatorShares.push({\n                                privateKey: `0x${shareSecretKey.serializeToHexStr()}`,\n                                publicKey: `0x${sharePublicKey.serializeToHexStr()}`,\n                                id,\n                            });\n                        }\n\n                        const response: ISharesKeyPairs = {\n                            validatorPrivateKey: `0x${this.validatorPrivateKey.serializeToHexStr()}`,\n                            validatorPublicKey: `0x${this.validatorPublicKey.serializeToHexStr()}`,\n                            shares: this.validatorShares,\n                        };\n                        resolve(response);\n                    });\n            } catch (error: any) {\n                reject(error);\n            }\n        });\n    }\n}\n\nexport default Threshold;\n", "import { decode, encode } from 'js-base64';\nimport JSEncrypt from '../JSEncrypt';\nimport { IShares } from '../Threshold';\n\nexport class InvalidOperatorKeyException extends Error {\n  public operator: any;\n\n  constructor(operator: { rsa: string, base64: string }, message: string) {\n    super(message);\n    this.operator = operator;\n  }\n}\n\nexport interface EncryptShare {\n    operatorPublicKey: string,\n    privateKey: string,\n    publicKey: string\n}\n\nexport default class Encryption {\n    private readonly operators: string[];\n    private readonly shares: IShares[];\n\n    RAW_OPERATOR_PUBLIC_KEY_SIGNATURE = RegExp(/------BEGIN RSA PUBLIC KEY-----/, 'gmi');\n\n    constructor(operators: string[], shares: IShares[]) {\n        this.operators = operators.map((publicKey: string) => {\n          if (this.RAW_OPERATOR_PUBLIC_KEY_SIGNATURE.test(publicKey)) {\n            return publicKey;\n          }\n          return decode(publicKey);\n        });\n        this.shares = shares;\n    }\n\n    encrypt(): EncryptShare[] {\n        const encryptedShares: EncryptShare[] = [];\n        Object.keys(this.operators).forEach((operator: any) => {\n            const encrypt = new JSEncrypt({});\n            try {\n              encrypt.setPublicKey(this.operators[operator]);\n            } catch (error) {\n              throw new InvalidOperatorKeyException(\n                {\n                  rsa: this.operators[operator],\n                  base64: encode(this.operators[operator]),\n                },\n                `Operator is not valid RSA Public Key: ${error}`\n              );\n            }\n            const encrypted = encrypt.encrypt(this.shares[operator].privateKey);\n            const encryptedShare: EncryptShare = {\n                operatorPublicKey: this.operators[operator],\n                privateKey: String(encrypted),\n                publicKey: this.shares[operator].publicKey,\n            };\n            encryptedShares.push(encryptedShare);\n            return encryptedShare;\n        });\n        return encryptedShares;\n    }\n}\n", "let index: any;\n\ntry {\n  window.crypto;\n  index = require('jsencrypt').JSEncrypt;\n} catch {\n  index = require('node-jsencrypt');\n}\n\nexport default index;\n", "import Web3 from 'web3';\nimport { Contract } from 'web3-eth-contract';\n\nexport class SSVNetworkContract {\n  static BLOCKS_PER_YEAR = 2398050;\n  protected contractAddress = '';\n  protected nodeUrl = '';\n  protected contracts: any = {};\n  protected web3Instances: any = {};\n\n  getWeb3(nodeUrl = process.env.NODE_URL || ''): Web3 {\n    if (!this.web3Instances[nodeUrl]) {\n      this.web3Instances[nodeUrl] = new Web3(String(nodeUrl || ''))\n    }\n    return this.web3Instances[nodeUrl];\n  }\n\n  async getLiquidationCollateral(): Promise<number> {\n    return this.getContract().methods.minimumBlocksBeforeLiquidation().call();\n  }\n\n  async getNetworkFee(): Promise<number> {\n    return this.getContract().methods.networkFee().call();\n  }\n\n  getContract(): Contract {\n    if (!this.contracts[this.contractAddress]) {\n      this.contracts[this.contractAddress] = this.getWeb3(this.nodeUrl);\n    }\n    return this.contracts[this.contractAddress];\n  }\n\n  setContractAddress(address: string) {\n    this.contractAddress = address;\n  }\n\n  setNodeUrl(nodeUrl: string) {\n    this.nodeUrl = nodeUrl;\n  }\n}\n", "import crypto from 'crypto';\nimport { scrypt } from 'scrypt-js';\nimport Wallet from 'ethereumjs-wallet';\nimport { keccak256, sha256 } from 'ethereumjs-util';\n\ninterface V4Keystore {\n  crypto: {\n    kdf: {\n      function: string,\n      params: {\n        dklen: number,\n        n: number,\n        r: number,\n        p: number,\n        salt: string\n      },\n      message: string\n    },\n    checksum: {\n      function: string,\n      params: any,\n      message: string\n    },\n    cipher: {\n      function: string,\n      params: {\n        iv: string\n      },\n      message: string\n    }\n  },\n  description: string,\n  pubkey: string,\n  path: string,\n  uuid: string\n  version: number\n}\n\n/**\n * Decrypt private key from key store data\n * Supports key store versions: v1, v3, v4\n *\n * Example of usage (Node env):\n *\n *  const keyStoreFilePath = path.join(process.cwd(), 'validator_keys', 'keystore.json');\n *  const keyStoreString: string = fs.readFileSync(keyStoreFilePath).toString();\n *  const keyStoreData = JSON.parse(keyStoreString);\n *  const keyStore = new EthereumKeyStore(keyStoreData);\n *  const password = 'testtest';\n *  console.log('Private Key:', await keyStore.getPrivateKey(password));\n */\nclass EthereumKeyStore {\n  private readonly keyStoreData: any;\n  private privateKey = '';\n  private wallet: Wallet | undefined;\n\n  /**\n   * Receive key store data from string or parsed JSON\n   * @param keyStoreData\n   */\n  constructor(keyStoreData: string | never) {\n    if (!keyStoreData) {\n      throw new Error('Key store data should be JSON or string');\n    }\n    this.keyStoreData = JSON.parse(String(keyStoreData));\n    if (!this.keyStoreData.version) {\n      throw new Error('Invalid keystore file');\n    }\n  }\n\n  getPublicKey(): string {\n    if (this.keyStoreData) {\n      switch (this.keyStoreData.version ?? this.keyStoreData.Version) {\n        case 1:\n          return this.keyStoreData.Address;\n        case 3:\n          return this.keyStoreData.id;\n        case 4:\n          return this.keyStoreData.pubkey;\n      }\n    }\n    return '';\n  }\n\n  /**\n   * Decrypt private key using user password\n   * @param password\n   */\n  async getPrivateKey(password = ''): Promise<string> {\n    // In case private key exist we return it\n    if (this.privateKey) return this.privateKey;\n    switch (this.keyStoreData.version) {\n      case 1:\n        this.wallet = await Wallet.fromV1(this.keyStoreData, password);\n        break;\n      case 3:\n        this.wallet = await Wallet.fromV3(this.keyStoreData, password, true);\n        break;\n      case 4:\n        this.wallet = await this.fromV4(this.keyStoreData, password);\n        break;\n    }\n    if (this.wallet) {\n      this.privateKey = this.wallet.getPrivateKey().toString('hex');\n      if (!this.privateKey) {\n        throw new Error('Invalid password');\n      }\n    }\n    return this.privateKey;\n  }\n\n  /**\n   * Import a wallet (Version 4 of the Ethereum wallet format).\n   *\n   * @param input A JSON serialized string, or an object representing V3 Keystore.\n   * @param password The keystore password.\n   */\n  public async fromV4(\n    input: string | V4Keystore,\n    password: string,\n  ): Promise<Wallet> {\n    const json: V4Keystore = typeof input === 'object' ? input : JSON.parse(input);\n\n    if (json.version !== 4) {\n      throw new Error('Not a V4 wallet');\n    }\n\n    let derivedKey: Uint8Array;\n    let kdfParams: any;\n    if (json.crypto.kdf.function === 'scrypt') {\n      kdfParams = json.crypto.kdf.params;\n      derivedKey = await scrypt(\n        Buffer.from(password),\n        Buffer.from(kdfParams.salt, 'hex'),\n        kdfParams.n,\n        kdfParams.r,\n        kdfParams.p,\n        kdfParams.dklen,\n      );\n    } else if (json.crypto.kdf.function === 'pbkdf2') {\n      kdfParams = json.crypto.kdf.params;\n\n      if (kdfParams.prf !== 'hmac-sha256') {\n        throw new Error('Unsupported parameters to PBKDF2');\n      }\n\n      derivedKey = crypto.pbkdf2Sync(\n        Buffer.from(password),\n        Buffer.from(kdfParams.salt, 'hex'),\n        kdfParams.c,\n        kdfParams.dklen,\n        'sha256',\n      );\n    } else {\n      throw new Error('Unsupported key derivation scheme');\n    }\n\n    const ciphertext = Buffer.from(json.crypto.cipher.message, 'hex');\n    const checksumBuffer = Buffer.concat([Buffer.from(derivedKey.slice(16, 32)), ciphertext]);\n    const hashFunctions: Record<string, any> = {\n      keccak256,\n      sha256,\n    };\n    const hashFunction: any = hashFunctions[json.crypto.checksum.function];\n    const mac: Buffer = hashFunction(checksumBuffer);\n    if (mac.toString('hex') !== json.crypto.checksum.message) {\n      throw new Error('Invalid password');\n    }\n\n    const decipher = crypto.createDecipheriv(\n      json.crypto.cipher.function,\n      derivedKey.slice(0, 16),\n      Buffer.from(json.crypto.cipher.params.iv, 'hex'),\n    );\n    const seed: Buffer = this.runCipherBuffer(decipher, ciphertext);\n    return new Wallet(seed);\n  }\n\n  /**\n   * @param cipher\n   * @param data\n   */\n  protected runCipherBuffer(cipher: crypto.Cipher | crypto.Decipher, data: Buffer): Buffer {\n    return Buffer.concat([cipher.update(data), cipher.final()]);\n  }\n\n  /**\n   * Convert byte array to string\n   * @param byteArray\n   */\n  static toHexString(byteArray: Uint8Array): string {\n    return Array.from(byteArray, (byte: number) => {\n      // eslint-disable-next-line no-bitwise\n      return (`0${(byte & 0xFF).toString(16)}`).slice(-2);\n    }).join('');\n  }\n}\n\nexport default EthereumKeyStore;\n"],
  "mappings": "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",
  "names": []
}
